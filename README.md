# OrderManager

## 클래스 다이어그램
![image](https://github.com/user-attachments/assets/ef9a20f9-285c-4e0a-a080-f11ba3979729)
`Order`      
: 주문 정보를 캡슐화한 도메인 엔티티   
   
`OrderRepository`   
: 주문 데이터를 로컬 저장소에 저장하거나 조회를 담당   
   
`OrderService`   
: 비즈니스 로직을 처리하는 서비스 계층으로, 주문 생성, 조회 등 주문과 관련된 비즈니스 로직을 관리   
   
`ExternalSystemTemplate(데이터 연동 템플릿)`   
: 템플릿 메서드 패턴을 사용하여 외부 시스템과의 통신 흐름을 정의하는 추상 클래스   
   
`ExternalHttpJsonService`
- ExternalSystemTemplate을 구현한 클래스
- 외부 시스템과 HTTP 통신을 통해 데이터를 주고받고 JSON 형식으로 데이터를 처리하는 역할을 수행<br>

## 데이터 연동 인터페이스
**템플릿 메소드 패턴**을 활용하여 데이터 연동 인터페이스를 구성하였습니다.

설계 요구사항 중 다음 두 가지를 고려했습니다:

1. **확장성 고려**: "향후 다른 형태의 외부 시스템과 연동할 가능성을 고려하여 설계의 유연성과 확장성을 확보하세요."
2. **로직 포함**: "인터페이스는 외부 시스템과의 통신 로직과 데이터 변환 로직을 포함해야 합니다."

이 두 요구사항을 분석한 결과, **템플릿 메소드 패턴**이 적합하다고 판단했습니다.

외부 시스템과의 통신 로직과 데이터 변환 로직이 핵심이며, 외부 시스템의 형태가 달라질 경우 **통신 방식**이나 **데이터 변환 방식**이 달라질 수 있습니다. 따라서, 이러한 세부 구현은 **추상 클래스**에서 정의된 추상 메소드를 통해 개별 구현체에서 처리하도록 설계했습니다.

데이터 연동 프로세스는 크게 **데이터 수신 후 변환**하거나, **데이터 변환 후 전송**하는 두 가지 주요 흐름으로 구성됩니다. 외부 시스템의 형태에 관계없이 이 흐름 자체는 동일하기 때문에, **템플릿 메소드**로 `fetchOrder`와 `sendOrder`를 정의하였습니다.

템플릿 메소드 패턴의 핵심은 **알고리즘의 뼈대**를 제공하면서, 구체적인 처리 로직은 하위 클래스에 위임하는 것입니다. 여기서 각 외부 시스템과의 세부적인 통신 방식과 데이터 변환 로직은 **구현체에서 제공**하게 됩니다. 그러나 큰 흐름(데이터 수신 및 전송)은 동일하므로, 이를 오버라이딩하지 않고 그대로 사용했습니다.

이와 같은 설계는 시스템이 확장될 때, 새로운 외부 시스템과의 연동을 쉽게 추가할 수 있는 유연성을 제공합니다.
